\section{DESAFIO - Parte 1} \label{sec:desafio1}

Estamos enviando pelos links abaixo alguns binários executáveis (ELF
64-bit LSB) que realizam tarefas bem simples, que podem ou não ser
úteis. O exercício é que você descubra o que esses binários fazem,
utilizando as ferramentas que julgar mais adequadas. Como resposta,
esperamos que você nos diga o que você acha que eles fazem e quais
foram as ferramentas usadas para isso, bem como uma linha geral do seu
ra- ciocínio para chegar às conclusões.\\\par


Binários:

\href{https://s3.amazonaws.com/chaordic-desafio-cloud/cc9621}{cc9621}

Primeiramente utilizei a ferramenta \emph{objdump}, e posteriormente
para afirmar a conjectura, o \emph{gdb} (ferramentas Unix).
\emph{Objdump} oferece algumas análises do cabeçalho e instruções,
mnemônicos da arquitetura em que foi compilado o executável, em nosso
caso, o formato Executable and Linkable Format (ELF). Com esta
ferramenta, extrai (através de engenharia reversa) apenas a seção que
nos interessa, a main. No qual representa o ponto de entrada de
execução da primeira instrução do programa. O \emph{gdb} foi utilizado
para executar o debug, do passo a passo do programa, no qual foi
transcrito para um programa na Linguagem C, como mostra o fonte em
\ref{lst:cc9621.c}.

Observações (a versão das ferramentas utilizadas nesta análise são):
\begin{verbatim}
GNU objdump (GNU Binutils) 2.33.1
Copyright (C) 2019 Free Software Foundation, Inc.
This program is free software; you may redistribute it under the terms of
the GNU General Public License version 3 or (at your option) any later version.
This program has absolutely no warranty.
\end{verbatim}

\begin{verbatim}
GNU gdb (GDB) 8.3.1
Copyright (C) 2019 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
\end{verbatim}

Abaixo mostra a tabela dinâmica de símbolos obtida com o comando:\\
\emph{objdump -T cc9621}

\begin{verbatim}
 1: cc9621:     file format elf64-x86-64

DYNAMIC SYMBOL TABLE:
 2: 0000000000000000      DF *UND*	0000000000000000  GLIBC_2.2.5 getenv
 3: 0000000000000000      DF *UND*	0000000000000000  GLIBC_2.2.5 fclose
 4: 0000000000000000      DF *UND*	0000000000000000  GLIBC_2.4   __stack_chk_fail
 5: 0000000000000000      DF *UND*	0000000000000000  GLIBC_2.2.5 fputs
 6: 0000000000000000      DF *UND*	0000000000000000  GLIBC_2.2.5 __libc_start_main
 7: 0000000000000000  w   D  *UND*	0000000000000000              __gmon_start__
 8: 0000000000000000      DF *UND*	0000000000000000  GLIBC_2.2.5 fopen
 9: 0000000000000000      DF *UND*	0000000000000000  GLIBC_2.7   __isoc99_scanf
10: 0000000000000000      DF *UND*	0000000000000000  GLIBC_2.2.5 strcat
\end{verbatim}

Podemos observar na linha 1 que o programa foi compilado para
arquitetura x86 de 64bits, logo veremos apenas mnemônicos x86. Das
linhas 2 à 10 observamos as chamadas a libs dinâmicas.

Para obter uma visão transversal do que o programa faz, foi feito a
desmontagem do programa, utilizando o comando:

\emph{objdump -d --no-show-raw-insn cc9621}

\lstinputlisting[caption = {Escreve em /tmp/USER},label={prog:cc9621}]{cc9621.as}
